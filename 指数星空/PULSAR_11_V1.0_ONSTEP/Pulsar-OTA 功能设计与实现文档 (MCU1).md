# Pulsar 项目 OTA 功能设计与实现文档 (MCU1)

**日期**：2026.01.26  
**适用模块**：Pulsar - MCU1 (OnStepX / 电机控制核心)  
**前置条件**：MCU2 已实现 Web OTA 功能

---

## 1. 概述

本文档描述 Pulsar 板载 **MCU1 (ESP32-PICO-MINI-02U)** 的 OTA 固件升级实现方案。MCU1 作为核心控制器运行 OnStepX 固件，负责望远镜电机控制、CAN 总线通信等关键任务。由于 MCU1 **没有直接的 WiFi 连接能力**（WiFi 功能由 MCU2 独占），其 OTA 升级需通过 **MCU2 作为中继代理** 完成。

## 2. 硬件架构分析

### 2.1 双 MCU 拓扑结构

```
[用户浏览器] --WiFi--> [MCU2: SmartWebServer] --UART--> [MCU1: OnStepX]
                       (ESP32-PICO)                        (ESP32-PICO)
                       WiFi AP 192.168.0.1                 电机控制/CAN总线
```

**关键硬件连接**：

**MCU1 和 MCU2 的 Serial2 引脚对应表**：

| 引脚名称 | GPIO 号 |       MCU1       |      MCU2      |  功能  |
| :--: | :----: | :--------------: | :------------: | :--: |
| TXD2 | GPIO21 | ONSTEP_TXD2 (TX) | WIFI_TXD2 (TX) | 串口输出 |
| RXD2 | GPIO22 | ONSTEP_RXD2 (RX) | WIFI_RXD2 (RX) | 串口输入 |

**物理交叉连接**：
```
MCU1                    MCU2
GPIO21 (TXD2) ————————— GPIO22 (RXD2)
GPIO22 (RXD2) ————————— GPIO21 (TXD2)
GND ———————————————————— GND
```

- **信号名说明**（原理图标记，不影响功能）：
  - MCU1：`ONSTEP_TXD2` / `ONSTEP_RXD2`（OnStep 系统命名）
  - MCU2：`WIFI_TXD2` / `WIFI_RXD2`（WiFi 系统命名）

- **通信参数**：115200 波特率，8N1 格式。

- **现有用途**：
  - LX200 指令透传（如 `:GR#` 查询赤经），MCU2 接收的命令转发给 MCU1。
  - ESP Flasher 模式下的串口直通（历史遗留功能）。

**相关概念**：ESP32 有两个硬件 UART：
- **Serial（TXD0/RXD0）**：主串口，用于 USB 烧录和开发调试。
- **Serial2（TXD2/RXD2 即 GPIO21/22）**：第二串口，用于 MCU1↔MCU2 通信。

### 2.2 为什么必须通过 UART？

1. **MCU1 无独立网络接口**：  
   Pulsar 硬件设计中，**仅 MCU2 配备天线和 WiFi 功能**，MCU1 的天线引脚未接出，无法建立独立的 WiFi 连接。
   
2. **USB 接口已被占用**：  
   MCU1 的 USB-to-Serial (TXD0/RXD0) 主要用于开发调试和首次烧录，野外使用时用户设备（手机/平板）无法直接连接 USB。
   
3. **现有通信信道复用**：  
   MCU2 与 MCU1 之间的 UART 通道已建立，复用该信道进行固件传输是最经济、最可靠的方案。

### 2.3 MCU1 Flash 分区策略

**✅ 已验证标准分区表**（与 Arduino 官方 "Minimal SPIFFS (1.9MB APP with OTA)" 一致）：

```csv
# Name,   Type, SubType, Offset,  Size,      Flags
nvs,      data, nvs,     0x9000,  0x5000,    -
otadata,  data, ota,     0xE000,  0x2000,    -
app0,     app,  ota_0,   0x10000, 0x1E0000,  -
app1,     app,  ota_1,   0x1F0000,0x1E0000,  -
spiffs,   data, spiffs,  0x3D0000,0x20000,   -
coredump, data, coredump,0x3F0000,0x10000,%  -
```

**分区说明**：

| 分区名        | 大小           | 用途                       |
| ---------- | ------------ | ------------------------ |
| nvs        | 20 KB        | 非易失性存储（配置、参数）            |
| otadata    | 8 KB         | OTA 元数据（当前活动分区、回滚标记）     |
| ***app0*** | ***1.9 MB*** | ***当前运行的 OnStepX 固件***   |
| ***app1*** | ***1.9 MB*** | ***OTA 升级目标分区（备份/新版本）*** |
| spiffs     | 128 KB       | SPIFFS 文件系统（Web 资源）      |
| coredump   | 64 KB        | 崩溃转储区（调试用）               |

---

## 3. 技术实现方案

### 3.1 整体流程概览

```
┌─────────────────────────────────────────────────────────────────┐
│ 1. 用户上传 MCU1 固件 (.bin) 到 MCU2 的 /update_mcu1 接口          │
│    [浏览器] --HTTP POST--> [MCU2: /update_mcu1]                  │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ 2. MCU2 缓冲固件数据并分片处理                                        │
│    • 计算总大小和 MD5 校验和                                          │
│    • 将固件分割为 2KB 的数据帧                                         │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ 3. MCU2 通过 UART 发送 OTA 协议帧给 MCU1                            │
│    [MCU2] --Serial2 (115200)--> [MCU1]                          │
│    • 开始帧 (START): 总大小、MD5、目标分区                             │
│    • 数据帧 (DATA): 序号、长度、数据块、CRC16                           │
│    • 结束帧 (END): 触发校验和切换                                     │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ 4. MCU1 接收并写入 Flash                                            │
│    • 初始化 OTA 分区 (Update.begin)                                 │
│    • 逐帧写入数据到 App1 分区                                         │
│    • 完成后校验 MD5，标记分区有效                                      │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ 5. MCU1 重启并从新分区启动                                            │
│    ESP.restart() -> Bootloader 切换到 App1 -> OnStepX 新版本运行    │
│    • 若启动失败 3 次，Bootloader 自动回滚到 App0                        │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 UART OTA 协议设计

#### 3.2.1 帧格式定义

**通用帧结构**：

| 帧头  | 命令  | 序号  | 数据长度 |   数据体   | CRC16 |
| :-: | :-: | :-: | :--: | :-----: | :---: |
| 2B  | 1B  | 2B  |  2B  | 0-2048B |  2B   |

- **帧头 (0xAA55)**：固定魔术字，用于帧同步。
- **命令类型**：
  - `0x01` START（开始）
  - `0x02` DATA（数据块）
  - `0x03` END（结束）
  - `0x04` ABORT（中止）
  - `0x10` ACK（确认）
  - `0x11` NACK（重传请求）
- **序号 (Seq)**：从 0 开始递增，DATA 帧用于检测丢包。
- **CRC16**：使用 CRC-16/CCITT-FALSE 算法，覆盖整个帧（不含 CRC 本身）。

#### 3.2.2 关键帧详细说明

**START 帧** (MCU2 → MCU1)：
- 包含固件总大小（字节）
- 固件完整的 MD5 校验值
- 目标分区标记（Auto/App0/App1）

**DATA 帧** (MCU2 → MCU1)：
- 包含数据块序号（从 0 开始）
- 数据长度（1-2048 字节）
- 实际固件数据内容

**ACK/NACK 帧** (MCU1 → MCU2)：
- ACK：成功接收，返回对应的序号和成功码
- NACK：失败，返回对应的序号和错误码

#### 3.2.3 错误码定义

| 错误码 | 含义 | 处理方式 |
|-------|------|---------|
| `0x00` | 成功 | 继续 |
| `0x01` | CRC 校验失败 | 重传该帧 |
| `0x02` | 序号不连续 | 重传缺失帧 |
| `0x03` | Flash 写入失败 | 中止升级 |
| `0x04` | 空间不足 | 中止升级 |
| `0x05` | MD5 校验失败 | 中止升级 |
| `0x06` | 超时 | 重传或中止 |

### 3.3 可靠性保障机制

#### 3.3.1 分层校验策略

1. **帧级 CRC16**：每帧独立校验，检测传输错误。
2. **序号连续性检查**：MCU1 检测 `seq` 是否连续，防止丢帧。
3. **整体 MD5 校验**：所有数据写入完成后，计算整个分区的 MD5 与 START 帧中的值对比。

#### 3.3.2 超时与重传机制

- **MCU2 发送超时**：每发送一帧后，等待 MCU1 的 ACK/NACK，超时 `500ms` 则重传，最多重传 `3` 次。
- **MCU1 接收超时**：若 `5` 秒内未收到下一帧，则认为传输中断，发送 ABORT 帧并清理 OTA 状态。

#### 3.3.3 Bootloader 自动回滚

ESP32 的 Bootloader 具备内置回滚功能：
- 新固件启动后必须调用 `esp_ota_mark_app_valid_cancel_rollback()` 标记为有效。
- 若新固件在启动阶段崩溃（如 `setup()` 中死循环），Bootloader 检测到连续启动失败 3 次后，会自动切换回旧分区，防止变砖。

---

## 4. 代码架构设计

### 4.1 MCU1 端核心模块

MCU1 需实现一个 **OTA 接收模块**，核心职责：

1. **UART 帧解析与状态机**：  
   在主循环中持续监听 Serial2，按照协议解析帧。维护状态机（IDLE → RECEIVING → VERIFYING → COMPLETED），根据当前状态处理不同的帧类型。

2. **Flash 写入管理**：  
   利用 Arduino 官方的 Update 库（流式 OTA API），逐帧将数据写入 app1 分区。若写入失败则立即中止并返回错误。

3. **校验与回滚防护**：  
   - 接收所有数据后，计算整个分区的 MD5，与 START 帧中的值对比。
   - 校验成功后调用 `Update.end(true)` 和 `esp_ota_mark_app_valid_cancel_rollback()` 标记分区有效，防止 Bootloader 回滚。
   - 若校验失败，清理 OTA 状态并等待用户重试。

4. **错误处理与日志**：  
   记录每个关键步骤（如接收帧数、写入字节数、CRC 结果、MD5 最终值），通过 Serial0 输出日志供调试。

### 4.2 MCU2 端核心功能

MCU2 需在现有 SmartWebServer 基础上扩展以下功能：

1. **Web 路由与上传处理**：  
   新增 `/update_mcu1` 接口，接收浏览器上传的 .bin 文件。采用流式处理方式（逐块接收、逐块处理），避免一次性缓存整个文件导致内存溢出。

2. **固件转发逻辑**：  
   - 接收上传的固件后，计算总大小和 MD5，组装 START 帧并发送给 MCU1。
   - 读取上传的数据流，每次取 2KB 分割成一个 DATA 帧，添加序号和 CRC16，通过 Serial2 发送。
   - 等待 MCU1 的 ACK/NACK 响应，若收到 NACK 则执行重传（最多 3 次），若超时则也进行重传。

3. **进度反馈与实时显示**：  
   记录已发送的数据字节数，计算百分比（已发送 / 总大小），通过 SSE 或 WebSocket 向浏览器实时推送进度。同时推送当前传输速度、剩余时间估算等信息。

4. **错误处理与恢复**：  
   若传输过程中 MCU1 返回错误，MCU2 记录错误信息并通过 Web 界面显示。用户可选择重试（从 START 帧重新开始）或中止。

---

## 5. 前端交互设计

### 5.1 更新页面改进

在现有 `/update.htm` 基础上增加升级目标选择功能：

- **MCU2 (本机 WiFi 模块)**：复用现有 `/update` 接口，直接升级 MCU2 自身的固件。
- **MCU1 (电机控制核心)**：新增 `/update_mcu1` 接口，通过 UART 转发升级 MCU1 的固件。

前端通过下拉选择框（或单选按钮）让用户选择升级目标，动态改变表单的 `action` 属性指向不同的端点。

### 5.2 进度反馈机制

MCU2 通过 SSE (Server-Sent Events) 或短周期轮询向浏览器实时推送升级进度：

- **实时进度百分比**：基于 MCU1 返回的已接收字节数计算。
- **传输速度显示**：根据时间间隔计算当前 KB/s 或 MB/s。
- **剩余时间估算**：根据当前速度预测剩余时间。
- **完成提示**：升级成功后自动更新页面状态，提示用户 MCU1 即将重启。

若升级失败，显示具体的错误代码和中文描述，并提供"重试"或"取消"的操作按钮。

---

## 6. 风险评估与应对

### 6.1 潜在风险点

| 风险点 | 影响 | 概率 | 应对措施 |
|-------|------|------|---------|
| **UART 传输中断** | 升级失败，需重试 | 中等 | • 超时重传机制<br>• 断点续传支持（记录已完成序号） |
| **MCU1 分区表不支持 OTA** | 无法升级 | 低 | • 编译时检查分区表<br>• 提供 USB 刷写指导文档 |
| **固件过大超过 1.9MB** | 写入溢出 | 低 | • 编译时警告<br>• MCU1 拒绝接收过大固件 |
| **新固件启动崩溃** | 功能丧失，需回滚 | 中等 | • 依赖 Bootloader 自动回滚<br>• 新固件必须调用 `mark_valid()` |
| **UART 波特率不匹配** | 通信失败 | 低 | • 硬编码 115200 波特率<br>• MCU2 检测握手失败时降低波特率重试 |
| **同时升级 MCU1 和 MCU2** | 系统全失效 | 极低 | • **禁止同时操作**<br>• 前端互斥锁定升级按钮 |

### 6.2 失败恢复策略

1. **传输失败**：  
   - 用户可在 Web 界面点击"重试"按钮，MCU2 重新上传固件。
   - MCU1 的旧固件仍然运行，不影响正常使用。

2. **启动失败**：  
   - Bootloader 自动回滚后，用户需通过 Web 界面查看错误日志（MCU1 通过 UART 回传错误信息）。
   - 若持续失败，提供 USB 刷写的降级方案。

3. **两台 MCU 失联**：  
   - 若 MCU2 在传输过程中复位，MCU1 会检测超时并清理 OTA 状态，恢复正常运行。
   - MCU2 重启后可重新发起升级。

---

## 7. 实施步骤与里程碑

### 7.1 第一阶段：基础框架（1 周）

- [ ] **MCU1 侧**：
  - 实现 UART 协议模块（帧解析、CRC 计算）。
  - 实现基本状态机框架（IDLE、RECEIVING、VERIFYING、COMPLETED）。
  - 单元测试：模拟接收 START 帧并初始化 OTA 分区。

- [ ] **MCU2 侧**：
  - 实现 OTA 转发器基础类。
  - 添加 `/update_mcu1` 路由和文件上传处理。
  - 单元测试：发送 START 帧并验证 MCU1 响应。

### 7.2 第二阶段：数据传输与校验（1 周）

- [ ] **MCU1 侧**：
  - 完成 DATA 帧接收和 Flash 写入逻辑。
  - 实现序号连续性检查和 CRC 校验。
  - 集成 MD5 校验和分区标记有效的调用。

- [ ] **MCU2 侧**：
  - 实现固件分片和 DATA 帧发送。
  - 实现 ACK/NACK 响应解析和重传逻辑。
  - 计算并传递固件 MD5 值。

### 7.3 第三阶段：前端集成与测试（3 天）

- [ ] 更新 Web 页面，增加 MCU1/MCU2 选择器。
- [ ] 实现进度条和错误提示 UI。
- [ ] 端到端测试：
  - 正常升级流程（小固件 < 500KB）。
  - 大固件传输（1.5MB）。
  - 故意中断（拔掉电源）验证回滚。
  - 刷入错误固件验证错误提示。

### 7.4 第四阶段：优化与文档（2 天）

- [ ] 日志完善：MCU1 和 MCU2 的详细日志输出。
- [ ] 性能优化：调整分片大小以平衡速度和稳定性。
- [ ] 用户文档：编写操作手册和故障排查指南。
- [ ] 代码注释和开发者文档。

---

## 8. 分区验证与初始化指南

**本节描述：在实施 OTA 功能前，如何验证 MCU1 的分区表是否已支持 OTA，以及若不支持时如何初始化。**

### 8.1 快速诊断：检查当前分区

#### 方法 1：Arduino IDE 内置工具（推荐新手）

1. **连接 MCU1**：USB 线连接 MCU1 到 PC。
2. **打开 Arduino IDE**，选择：
   - **工具** → **端口** → 选择 MCU1 的串口（如 `/dev/ttyUSB0`）
   - **工具** → **开发板** → `ESP32 PICO-D4`（或 `ESP32-PICO-MINI`）
3. **打开串口监视器**（波特率 115200），重启 MCU1。
4. **观察启动日志**，寻找以下关键信息：

```
E (200) esp_image: Image has invalid magic byte (expected 0xE9, got 0xFF)
W (207) esp_ota_core: OTA partition invalid!
E (214) boot: OTA App0 invalid!
```

**诊断结果**：
- 若看到 `OTA partition invalid` → 分区表不支持 OTA，**需要重新烧录**
- 若看到 `OTA App0 valid`  → 分区表正确，**无需处理**

#### 方法 2：命令行工具（推荐熟悉 CLI 的开发者）

```bash
# 1. 确保已安装 esptool（如未安装则执行 pip install esptool）
pip install esptool

# 2. 读取 MCU1 的分区表
esptool.py --port /dev/ttyUSB0 read_flash 0x8000 0xC00 partition_table.bin

# 3. 查看分区内容
python -c "
import struct
with open('partition_table.bin', 'rb') as f:
    data = f.read()
    for i in range(0, len(data), 32):
        if data[i:i+2] == b'\\xAA\\x50':  # 分区表魔术字
            name = data[i+2:i+18].rstrip(b'\\x00').decode()
            print(f'Found partition: {name}')
"
```

**若输出包含**：
```
Found partition: app0
Found partition: app1
Found partition: otadata
```

则表示 ✅ **分区表正确**。

### 8.2 若分区不支持 OTA 时：初始化分区表

**前置条件**：MCU1 可通过 USB 烧录。

#### 步骤 1：在 Arduino IDE 中配置分区方案

1. **打开 Arduino IDE**，新建或打开任意 ESP32 sketch。
2. **工具 → 开发板**：选择 `ESP32 PICO-D4` 或匹配 MCU1 的型号。
3. **工具 → Partition Scheme**：选择 **`Minimal SPIFFS (1.9MB APP with OTA)`**
4. **工具 → 端口**：选择 MCU1 的串口。

#### 步骤 2：编译并烧录一个测试固件

编写并上传一个简单的测试 sketch，主要目的是初始化分区表。该 sketch 在 `setup()` 中标记 OTA 分区有效，防止 Bootloader 回滚。烧录过程中会看到 `Flashing init data default...` 和 `Wrote 0x ... bytes` 的信息。这一步会同时更新 Bootloader 和分区表。

#### 步骤 3：验证分区已更新

烧录完成后，打开串口监视器（波特率 115200）重新启动 MCU1，观察输出日志。如果看到 `boot: Trying app0 partition...` 等信息说明分区表已正确初始化。

**这是正常的！** 因为我们刚刚清除了所有 app 分区。现在通过 Arduino IDE 再烧录一次真实的 OnStepX 固件即可。

#### 步骤 4：烧录 OnStepX 正式固件

1. **打开 OnStepX 项目**的 `OnStepX.ino`（你当前工作的项目）。
2. **确保分区方案依然选中**：**Minimal SPIFFS (1.9MB APP with OTA)**。
3. **点击上传**，烧录完整的 OnStepX 固件。
4. **MCU1 正常启动后，验证**：用 esptool 再次读取分区，确认 otadata 已被写入。

### 8.3 完整初始化流程检查表

| 步骤 | 操作 | 验证标志 |
|------|------|---------|
| 1 | MCU1 通过 USB 连接 PC | 识别到串口设备 |
| 2 | Arduino IDE 配置分区方案为 `Minimal SPIFFS (1.9MB APP with OTA)` | 工具菜单中该选项被勾选 |
| 3 | 编译并烧录测试 sketch | 烧录进度达到 100% |
| 4 | MCU1 重启后打开串口监视器 | 可看到启动日志（即使无有效固件也无关紧要） |
| 5 | 烧录 OnStepX 正式固件 | 烧录完成，MCU1 正常启动 |
| 6 | 运行 `esptool` 验证分区表 | 输出包含 `app0`, `app1`, `otadata` |
| 7 | 在 MCU1 串口监视器中看到 OnStepX 启动日志 | 例如 "MSG: OnStepX, version 10.27c" |

---

## 9. 性能预估

### 9.1 升级时间预估

假设固件大小为 `1.5 MB`，UART 波特率为 `115200 bps`：

- **理论传输速率**：115200 / 10 ≈ `11.52 KB/s`（考虑起始位/停止位）
- **实际有效速率**：约 `10 KB/s`（考虑帧开销、ACK 延迟）
- **预计传输时间**：1.5 MB / 10 KB/s = `150 秒` ≈ **2.5 分钟**
- **加上校验和重启**：总耗时约 **3 分钟**

### 9.2 优化方向

1. **提高波特率**：  
   - 尝试使用 `230400` 或 `460800` bps，可将时间缩短至 1-1.5 分钟。
   - 需测试高波特率下的误码率。

2. **压缩固件**：  
   - 使用 gzip 压缩 .bin 文件，MCU1 解压后写入（需额外 RAM）。

3. **并行校验**：  
   - 边传输边计算 MD5，减少校验等待时间。

---

## 10. 测试计划

### 10.1 功能测试用例

| 用例编号 | 测试场景 | 预期结果 | 测试状态 |
|---------|---------|---------|---------|
| TC-01 | 正常升级 1.0 MB 固件 | 成功写入，重启运行新版本 | ⬜ 未测试 |
| TC-02 | 上传 2.0 MB 固件（超限） | MCU1 拒绝并返回错误码 `0x04` | ⬜ 未测试 |
| TC-03 | 传输中故意断电 MCU2 | MCU1 超时中止，旧固件继续运行 | ⬜ 未测试 |
| TC-04 | 发送错误 CRC 的 DATA 帧 | MCU1 返回 NACK，MCU2 重传 | ⬜ 未测试 |
| TC-05 | 新固件在 `setup()` 中死循环 | Bootloader 回滚到旧分区 | ⬜ 未测试 |
| TC-06 | 同时打开两个浏览器升级 MCU1 | 第二个请求被拒绝（互斥锁） | ⬜ 未测试 |

### 10.2 压力测试

- **连续升级 10 次**：验证 Flash 擦写寿命和稳定性。
- **弱信号环境**：在 WiFi 信号边缘测试传输可靠性。
- **低电压测试**：在电池电量不足情况下测试是否会变砖。

---

## 11. 后续演进方向

### 11.1 短期改进

1. **断点续传**：  
   - 记录已传输的最后序号，传输中断后从该点继续，避免重新上传。

2. **版本校验**：  
   - 在 START 帧中增加固件版本号字段，MCU1 拒绝降级或重复刷写相同版本。

3. **固件签名验证**：  
   - 使用 RSA/ECDSA 签名，防止恶意固件注入。

### 11.2 长期规划

1. **无线 OTA 中继链**：  
   - 支持通过 MCU2 同时升级多个下游设备（如未来增加的 MCU3）。

2. **云端固件仓库**：  
   - MCU2 定期从云服务器拉取最新固件，自动提示用户升级。

3. **A/B 无缝切换**：  
   - 类似 Android 系统，后台下载并写入备份分区，下次重启直接切换，用户无感知。

---

## 12. 附录

### 12.1 相关文档

- [Pulsar-OTA 功能设计与实现文档 (MCU2).md](./Pulsar-OTA%20功能设计与实现文档%20(MCU2).md)
- [U1_引脚定义.md](./U1_引脚定义.md)
- [Arduino OTA 官方文档](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/ota.html)

### 12.2 代码仓库结构（规划）

```
OnStepX/
├── src/
│   ├── telescope/
│   │   └── ota/                     # 新增 OTA 模块
│   │       ├── OtaReceiver.h        # OTA 接收器头文件
│   │       ├── OtaReceiver.cpp      # OTA 接收器实现
│   │       ├── UartProtocol.h       # UART 协议定义
│   │       └── UartProtocol.cpp     # 协议解析实现
│   └── pinmaps/
│       └── Pins.MaxESP3.h           # 已确认 SERIAL_B 定义
└── tools/
    └── ota_test_scripts/            # 测试脚本目录
        ├── send_fake_firmware.py    # 模拟 MCU2 发送固件脚本
        └── verify_partition.sh      # 验证分区表脚本
```

### 12.3 CRC16 计算算法说明

使用标准的 CRC-16/CCITT-FALSE 算法计算帧校验：

1. 初始值：`0xFFFF`
2. 多项式：`0x1021`
3. 输入反射：不进行
4. 输出反射：不进行
5. 最终异或值：`0x0000`

---

**文档版本**：v1.2（简化版）
**编写者**：Pulsar 开发团队  
**审阅状态**：等待集成验证  
**更新历史**：
- v1.0 (2026.01.26)：初稿，OTA 架构和协议设计
- v1.1 (2026.01.26)：集成分区验证报告，补充初始化指南
- v1.2 (2026.01.26)：删除所有具体代码实现，保留纯设计思路和架构说明

**关键前置条件**：✅ MCU1 分区表已验证为标准 OTA 格式，100% 兼容 Arduino 官方标准
