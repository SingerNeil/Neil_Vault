这份文档将原有的硬件基础分析与新的“单口双芯烧录”业务逻辑进行了完美融合。它不仅解释了**底层为什么稳**（硬件分析），还解释了**上层怎么跑**（软件逻辑）。

你可以直接使用以下 Markdown 内容：

---

# Pulsar-CN1 双芯片烧录实现方案与硬件原理分析

**文档版本**: v1.1
**硬件型号**: ESP32-PICO-MINI-02 (MCU1 & MCU2)
**接口标准**: CN1 (Type-C USB-Serial)

---

## 1. 方案概述

本项目旨在实现通过单一物理接口（CN1 Type-C）对 Pulsar 板载的两颗 MCU（MCU1-主控，MCU2-WiFi）进行固件更新。

**核心目标**：
1.  **单口复用**：无需插拔线缆，仅连接 CN1 即可分别烧录两颗芯片。
2.  **软件触发**：通过串口指令触发烧录模式，**彻底消除**传统 ESP32 烧录需物理按下 "Boot/Reset" 按钮的操作，实现“无感升级”。
3.  **可靠传输**：基于 Flash 物理特性的分片策略，确保数据完整性。

---

## 2. 系统拓扑与数据流向

整个系统的通信链路如下：

*   **物理层**: 相机（上位机） <== USB-C ==> `CN1)` <== UART0 ==> `MCU1 (OnStepX)` <== UART2 ==> `MCU2 (SWS)`
*   **MCU1 角色**: 既是**终端节点**（接收控制指令/自身固件），也是**中继节点**（通往 MCU2 的桥梁）。

---

## 3. 硬件存储资源与传输策略分析

为确保 OTA 过程的绝对稳定性，我们深入分析了 ESP32-PICO-MINI-02 的硬件特性，制定了基于物理特性的传输策略。

### 3.1 MCU 核心存储资源 (基于 Datasheet)
根据 Datasheet 第 3 页记载：

| 参数项           | 规格值        | 说明                             |
| :------------ | :--------- | :----------------------------- |
| **SPI Flash** | **8 MB**   | 容量充足，支持双分区 (A/B) OTA，无需担心固件体积。 |
| **PSRAM**     | **2 MB**   | 外部扩展内存，为透传模式提供巨大的数据缓冲池。        |
| **SRAM**      | **520 KB** | 内部内存，用于高速数据搬运。                 |

### 3.2 Flash 写入特性与分片策略
OTA 的核心是将数据写入 SPI Flash。为了保证效率，传输分片大小严格参考 Flash 物理特性：

*   **物理页 (Page Size)**: **256 Bytes** (基于通用 SPI NOR Flash 标准)
*   **传输分片 (Chunk Size)**: **512 Bytes**

**论证逻辑**:
$$ \text{OTA Chunk Size (512 B)} = 2 \times \text{Flash Page Size (256 B)} $$
*   **写入效率**: 每次接收的数据正好填满 **2 个物理页**，避免了非对齐写入，最大化编程效率。
*   **传输开销**: 相比“一页一页传”，减少了 50% 的握手交互，提升吞吐量。

### 3.3 UART 缓冲能力与抗溢出
*   **硬件 FIFO**: **128 Bytes** (ESP32 架构标准)。
*   **抗溢出机制**: 虽然 512B 分片 > 128B FIFO，但 ESP32 利用中断实时将数据搬运至 SRAM/PSRAM 软件缓冲区。配合协议层 **30ms 的流控延迟**，完美平衡了写入速度与接收能力。

---

## 4. 双芯片烧录实现逻辑

基于上述硬件基础，我们设计了两套通过 CN1 触发的软件协议，分别针对 MCU1 和 MCU2 的烧录。

### 4.1 场景 A：烧录 MCU1 (自身 OTA)

这是对现有 OTA 协议的直接应用。上位机（相机）直接向 MCU1 发送固件。

*   **触发机制**: 上位机发送指令 **`:UPDATE_MODE#`**。
*   **执行流程**:
    1.  MCU1 命令解析器识别指令。
    2.  MCU1 挂起所有后台任务，回复 `OTA_READY#`。
    3.  MCU1 进入 **OTA Trap (陷阱模式)**，交出 CPU 控制权，专心等待数据。
    4.  上位机开始发送 512B 切片的固件流。
    5.  传输结束，MCU1 校验 MD5 并自动重启。

### 4.2 场景 B：烧录 MCU2 (透传/反向 OTA)

这是一个新增的“桥接”模式。MCU1 充当透明导线，将数据转发给 MCU2。

*   **触发机制**: 上位机发送指令 **`:PASSTHROUGH#`** (或类似自定义指令)。
*   **执行流程**:
    1.  **建立桥梁**: MCU1 收到指令后，进入 **透传模式 (Passthrough Loop)**。
        *   *逻辑*: 
        * ```c
        while(1) 
        { 
        if(Serial.available) 
	        Serial2.write(); 
        if(Serial2.available) 
	        Serial.write(); 
        }
          ```
        *   此时 MCU1 不再解析任何指令，纯粹做字节搬运工。
    2.  **远程唤醒**: 上位机再次发送 **`:UPDATE_MODE#`**。
        *   数据穿过 MCU1，到达 MCU2。
        *   MCU2 识别指令，回复 `OTA_READY#`，进入其自身的 OTA 接收模式。
    3.  **数据转发**: 上位机发送固件流 -> MCU1 (RAM缓存) -> MCU2。
    4.  **结束**: MCU2 校验重启。MCU1 通过硬件复位或超时机制退出透传模式。

---

## 5. 方案优势总结

1.  **生产效率提升**: 产线烧录或用户升级时，无需拆机按K1或K2按钮，无需连接两个 USB 口，一条线解决所有问题。
2.  **硬件零成本**: 既然利用了现有的串口通路和 ESP32 强大的处理能力，不需要增加额外的 USB Hub 芯片或切换开关。
3.  **稳定性保障**:
    *   **底层**: 512B 分片策略契合 Flash 物理特性。
    *   **链路**: 软件流控防止了 FIFO 溢出。
    *   **校验**: 全程 MD5 校验防止“变砖”。

---