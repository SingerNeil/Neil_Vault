## KTech 电机 CAN 指令格式说明

### 0x80 电机失能指令

**指令格式：**
```
ID: 0x141 (0x140 + 轴号)
Data: 80 00 00 00 00 00 00 00
```

**字节含义：**

| 字节位置 | 十六进制值 | 含义 | 说明 |
|---------|-----------|------|------|
| Byte 0  | `0x80`    | **命令码** | 表示"电机失能"命令 |
| Byte 1  | `0x00`    | 预留/无效 | 此命令无需参数 |
| Byte 2  | `0x00`    | 预留/无效 | 此命令无需参数 |
| Byte 3  | `0x00`    | 预留/无效 | 此命令无需参数 |
| Byte 4  | `0x00`    | 预留/无效 | 此命令无需参数 |
| Byte 5  | `0x00`    | 预留/无效 | 此命令无需参数 |
| Byte 6  | `0x00`    | 预留/无效 | 此命令无需参数 |
| Byte 7  | `0x00`    | 预留/无效 | 此命令无需参数 |

---

### 其他 KTech 电机指令对比

为便于理解，这里列出代码中使用的所有指令：

#### 1. **0x88 电机使能**
```
Data: 88 00 00 00 00 00 00 00
```
- Byte 0: `0x88` = 命令码（使能）
- Byte 1-7: `0x00` = 无参数

#### 2. **0x95 设置零点**
```
Data: 95 00 00 00 [PP PP PP PP]
```
- Byte 0: `0x95` = 命令码（设置零点）
- Byte 1-3: `0x00` = 预留
- Byte 4-7: `[PP PP PP PP]` = **4 字节位置值**（32 位有符号整数，小端序）

#### 3. **0xA3 设置目标位置**
```
Data: A3 00 00 00 [TT TT TT TT]
```
- Byte 0: `0xA3` = 命令码（设置位置）
- Byte 1-3: `0x00` = 预留
- Byte 4-7: `[TT TT TT TT]` = **4 字节目标位置**（32 位有符号整数，小端序）

#### 4. **0x9A 请求状态**
```
Data: 9A 00 00 00 00 00 00 00
```
- Byte 0: `0x9A` = 命令码（请求状态）
- Byte 1-7: `0x00` = 无参数

---

### 总结

**0x80 指令的数据来源：**
- 第 1 字节 `0x80` 是 KTech 电机协议中定义的**失能命令码**
- 后续 7 字节全部为 `0x00`，因为该命令**不需要任何参数**

**发送方式：**
- CAN ID = `0x140 + 轴号`（例如轴 1 = 0x141）
- 数据长度 = 8 字节
- 无需等待应答（best-effort 方式）

---

# 0x95 和 0xA3 指令的 4 字节位置数据编码说明

## 数据格式

这 4 字节数据是 **32 位有符号整数（int32_t/long）**，采用 **小端序（Little-Endian）** 编码。

## 编码过程

代码中使用指针直接转换内存数据：

**0x95 设置零点：**
```cpp
long value = 某个位置值;
canPlus.write((uint8_t*)&value, 4);  // 将 long 的 4 字节内存直接写入
```

**0xA3 设置目标位置：**
```cpp
long target = motorSteps + backlashSteps;
canPlus.write((uint8_t*)&target, 4);  // 将 long 的 4 字节内存直接写入
```

## 小端序编码规则

**数值范围：** -2,147,483,648 到 +2,147,483,647（32位有符号整数）

**编码方式：** 最低有效字节（LSB）放在最前面

---

## 实际例子

#### 例子 1：正数位置值

**位置值：** `1000` (十进制)

**转换过程：**
1. 十进制 `1000` = 十六进制 `0x000003E8`
2. 32位表示：`00 00 03 E8`
3. **小端序排列：** `E8 03 00 00`

**完整 CAN 数据包：**
```
0xA3 指令: A3 00 00 00 E8 03 00 00
           [命令][预留] [位置=1000]
```

---

#### 例子 2：较大正数

**位置值：** `100000` (十进制)

**转换过程：**
1. 十进制 `100000` = 十六进制 `0x000186A0`
2. 32位表示：`00 01 86 A0`
3. **小端序排列：** `A0 86 01 00`

**完整 CAN 数据包：**
```
0x95 指令: 95 00 00 00 A0 86 01 00
           [命令][预留] [位置=100000]
```

---

#### 例子 3：负数位置值

**位置值：** `-500` (十进制)

**转换过程：**
1. 十进制 `-500` = 十六进制 `0xFFFFFE0C`（补码表示）
2. 32位表示：`FF FF FE 0C`
3. **小端序排列：** `0C FE FF FF`

**完整 CAN 数据包：**
```
0xA3 指令: A3 00 00 00 0C FE FF FF
           [命令][预留] [位置=-500]
```

---

#### 例子 4：零点

**位置值：** `0` (十进制)

**转换过程：**
1. 十进制 `0` = 十六进制 `0x00000000`
2. 32位表示：`00 00 00 00`
3. **小端序排列：** `00 00 00 00`

**完整 CAN 数据包：**
```
0x95 指令: 95 00 00 00 00 00 00 00
           [命令][预留] [位置=0]
```

---

### 代码实现位置

**0x95 设置零点：** KTech.cpp#L172-L178
```cpp
static const uint8_t cmd[] = "\x95\x00\x00\x00";
canPlus.txWait();
canPlus.beginPacket(canID);
canPlus.write(cmd, 4);              // 写入命令码 + 3字节预留
canPlus.write((uint8_t*)&value, 4); // 写入4字节位置值（自动小端序）
canPlus.endPacket();
```

**0xA3 设置目标位置：** KTech.cpp
```cpp
static const uint8_t cmd[] = "\xa3\x00\x00\x00";
canPlus.txWait();
canPlus.beginPacket(canID);
canPlus.write(cmd, 4);               // 写入命令码 + 3字节预留
canPlus.write((uint8_t*)&target, 4); // 写入4字节目标位置（自动小端序）
canPlus.endPacket();
```

---

## 要点

1. **数据类型：** 32位有符号整数（int32_t）
2. **字节序：** 小端序（最低字节在前）
3. **取值范围：** -2,147,483,648 到 +2,147,483,647
4. **位置单位：** 步进值（steps），具体物理意义取决于电机配置
